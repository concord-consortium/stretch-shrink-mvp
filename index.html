
<!DOCTYPE html>
<html> 
<head> 
<title>GeoGebra and JavaScript</title> 
<script src="https://cdn.geogebra.org/apps/deployggb.js"></script>

</head> 
 
<body> 
 
<div> 

<div id="ggbApplet"></div>

<div id="ggbApplet2"></div>

 
<script type="text/javascript"> 

  var lockNames = ["sheetListener", "pointListener", "dilationListener", "sheetTransformationListener", "ruleListener"],
      availableLocks = ["sheetListener", "pointListener", "dilationListener", "sheetTransformationListener", "ruleListener"],
      objectsToListeners = {},

      app1Loaded = false,
      app2Loaded = false,

      pointNames = [];

function ggbOnInit(param) {
  if (param == "ggbApplet") {
    app1Loaded = true;
  }
  if (param == "ggbApplet2") {
    addSheetListeners();
    app2Loaded = true;
  }

  if (app1Loaded && app2Loaded) {
    makePolygonFromSpreadsheet("A", "B");
    makePolygonFromSpreadsheet("D", "E", "'");
    makeMidpoints();
  }
}

function addSheetListeners() {
  addListener(ggbApplet2, "A3", "sheetListener");
  addListener(ggbApplet2, "B3", "sheetListener");
  addListener(ggbApplet2, "A4", "sheetListener");
  addListener(ggbApplet2, "B4", "sheetListener");
  addListener(ggbApplet2, "A5", "sheetListener");
  addListener(ggbApplet2, "B5", "sheetListener");

  addListener(ggbApplet2, "D2", "ruleListener");
  addListener(ggbApplet2, "E2", "ruleListener");
}

function addListener(app, objName, functionName) {
  if (objectsToListeners[objName] === undefined) {
    app.registerObjectUpdateListener(objName, functionName);
    objectsToListeners[objName] = {app, functionName};
  }
}

function removeAllListeners() {
  Object.keys(objectsToListeners).forEach(objName => {
    let app = objectsToListeners[objName].app;
    app.unregisterObjectUpdateListener(objName);
  });
}

function reAddAllListeners() {
  Object.keys(objectsToListeners).forEach(objName => {
    let app = objectsToListeners[objName].app,
        functionName = objectsToListeners[objName].functionName;
    app.registerObjectUpdateListener(objName, functionName);
  });
}

function lock(lockName) {
  let lockIndex = availableLocks.indexOf(lockName);
  if (lockIndex > -1) {
    availableLocks.splice(lockIndex, 1);
  }
}

function nextChar(c) {
  return String.fromCharCode(c.charCodeAt(0) + 1);
}

function gridObjToSpreadSheetRow(gridObj) {
  let objNum = gridObj.charCodeAt(0),
      objNumDelta = objNum - 65;

  return objNumDelta + 3;
}

// Retrieves max coords from the graph
function getMaxCoords(pointSuffix="") {
  let maxX = 0,
      maxY = 0;
  pointNames.forEach(basePointName => {
    let pointName = basePointName + pointSuffix,
        x = ggbApplet.getXcoord(pointName),
        y = ggbApplet.getYcoord(pointName);

    if (x > maxX) {
      maxX = x;
    }
    if (y > maxY) {
      maxY = y;
    }
  });

  return [maxX, maxY];
}

function spreadSheetRowToGridObj(spreadsheetRow) {
  return String.fromCharCode(65 + (spreadsheetRow - 3));
}

function getPointCoords(pointName, pointSuffix="") {
  let fullPointName = pointName + pointSuffix;
  return [ggbApplet.getXcoord(fullPointName), ggbApplet.getYcoord(fullPointName)];
}

function getRowCoords(rowNum, xCol = "A", yCol = "B") {
  return [ggbApplet2.getValue(xCol + rowNum), ggbApplet2.getValue(yCol + rowNum)];
}

function arePointsDifferent(point1, point2) {
  return (Math.abs(point1[0] - point2[0]) > 0.01 || Math.abs(point1[1] - point2[1]) > 0.01)
}

function makePolygonFromSpreadsheet(xColumn, yColumn, pointSuffix = "") {
  let coords = [],
      row = 3,
      pointName = "A",
      polyString = "Poly" + pointSuffix + " = Polygon(";
  while (true) {
    let xCoord = ggbApplet2.getValue(xColumn + row),
        yCoord = ggbApplet2.getValue(yColumn + row);

    if (!isNaN(xCoord) && !isNaN(yCoord)) {
      ggbApplet.evalCommand(pointName + pointSuffix + " = (" + xCoord + ", " + yCoord + ")");
      polyString += pointName + pointSuffix + ", ";
      if (pointNames.indexOf(pointName) === -1) {
        pointNames.push(pointName);
      }
    } else {
      polyString = polyString.slice(0, polyString.length - 2) + ")";
      ggbApplet.evalCommand(polyString);

      pointNames.forEach(pointName => {
        addListener(ggbApplet, pointName, "pointListener");
      });

      break;
    }

    row++;
    pointName = nextChar(pointName);
  }
}

// Assuming that the graph points are correct, draws in new midpoints
function makeMidpoints() {
  let maxCoords = getMaxCoords("'"),
      maxX = maxCoords[0],
      maxY = maxCoords[1];

  ggbApplet.evalCommand("X_MID = (" + maxX/2 + ", " + maxY + ")");
  ggbApplet.evalCommand("X_ZERO = (" + 0 + ", " + maxY + ")");
  ggbApplet.evalCommand("Y_MID = (" + maxX + ", " + maxY/2 + ")");
  ggbApplet.evalCommand("Y_ZERO = (" + maxX + ", " + 0 + ")");
  ggbApplet.evalCommand("XY_MAX = (" + maxX + ", " + maxY + ")");

  ggbApplet.setColor("X_MID", 255, 0, 0);
  ggbApplet.setColor("Y_MID", 255, 0, 0);
  ggbApplet.setColor("XY_MAX", 255, 0, 0);
  ggbApplet.setVisible("X_ZERO", false);
  ggbApplet.setVisible("Y_ZERO", false);

  ggbApplet.evalCommand("TOP_SEG = Segment(X_ZERO, XY_MAX)");
  ggbApplet.evalCommand("RIGHT_SEG = Segment(Y_ZERO, XY_MAX)");
  ggbApplet.setLineStyle("TOP_SEG", 1);
  ggbApplet.setLineStyle("RIGHT_SEG", 1);

  addListener(ggbApplet, "Y_MID", "dilateXListener");
  addListener(ggbApplet, "X_MID", "dilateYListener");
}

function getDilationRules() {
  let xRule = ggbApplet2.getValueString("D2"),
      yRule = ggbApplet2.getValueString("E2");

  return [parseFloat(xRule.slice(0, xRule.indexOf("x"))), parseFloat(yRule.slice(0, yRule.indexOf("y")))];
}

// Dilates a point in the graph and corresponding row in spreadsheet. Bases dilation
// off of base position and rules from the spreadsheet.
function dilatePoint(pointName) {
  // Update transformed point coords in spreadsheet
  let dilationRules = getDilationRules(),
      spreadsheetRow = gridObjToSpreadSheetRow(pointName),
      baseCoords = getRowCoords(spreadsheetRow);
      dilatedCoords = [baseCoords[0] * dilationRules[0], baseCoords[1] * dilationRules[1]];

  ggbApplet2.setValue("D" + spreadsheetRow, dilatedCoords[0]);
  ggbApplet2.setValue("E" + spreadsheetRow, dilatedCoords[1]);

  // Update transformed points on graph
  ggbApplet.setCoords(pointName + "'", dilatedCoords[0], dilatedCoords[1]);
}

function pointListener(objName) {
  removeAllListeners();

  console.log("Point listener: " + objName);
  let newCoords = getPointCoords(objName),
      spreadsheetRow = gridObjToSpreadSheetRow(objName),
      oldCoords = getRowCoords(spreadsheetRow);

  // Update point coords in spreadsheet
  ggbApplet2.setValue("A" + spreadsheetRow, newCoords[0]);
  ggbApplet2.setValue("B" + spreadsheetRow, newCoords[1]);

  // Update transformed point coords in spreadsheet
  dilatePoint(objName);

  makeMidpoints();

  reAddAllListeners();
}

function sheetListener(objName) {
  removeAllListeners();
  
  console.log("Sheet listener: " + objName);
  let spreadsheetRow = parseInt(objName.slice(1)),
      gridObj = spreadSheetRowToGridObj(spreadsheetRow),
      oldCoords = getPointCoords(gridObj),
      newCoords = getRowCoords(spreadsheetRow);

  // Update point coords on graph
  ggbApplet.setCoords(gridObj, newCoords[0], newCoords[1]);

  dilatePoint(gridObj);

  makeMidpoints();

  reAddAllListeners();
}

// TODO: merge these into a single dilate listener
function dilateXListener(objName) {
  removeAllListeners();

  console.log("Dilate X listener: " + objName);
  let newX = ggbApplet.getXcoord(objName),
      baseX = getMaxCoords()[0],
      dilation = Math.round(newX / baseX * 100) / 100;

  ggbApplet2.setTextValue("D2", dilation + "x");

  pointNames.forEach(pointName => {
    dilatePoint(pointName);
  });

  makeMidpoints();

  reAddAllListeners();
}

function dilateYListener(objName) {
  removeAllListeners();

  console.log("Dilate Y listener: " + objName);
  let newY = ggbApplet.getYcoord(objName),
      baseY = getMaxCoords()[1],
      dilation = Math.round(newY / baseY * 100) / 100;

  ggbApplet2.setTextValue("E2", dilation + "y");

  pointNames.forEach(pointName => {
    dilatePoint(pointName);
  });

  makeMidpoints();

  reAddAllListeners();
}

function ruleListener(objName) {
  removeAllListeners();

  console.log("Rule listener: " + objName);
  pointNames.forEach(pointName => {
    dilatePoint(pointName);
  });

  makeMidpoints();

  reAddAllListeners();
}

var parameters = {
"id": "ggbApplet",
"width":1000,
"height":750,
"showMenuBar":true,
"showAlgebraInput":false,
"showToolBar":true,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id":"c23xKskj"};


var parameters2 = {
"id": "ggbApplet2",
"width":1000,
"height":750,
"showMenuBar":true,
"showAlgebraInput":false,
"showToolBar":true,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id":"uKg8Y9WS",
};

// is3D=is 3D applet using 3D view, AV=Algebra View, SV=Spreadsheet View, CV=CAS View, EV2=Graphics View 2, CP=Construction Protocol, PC=Probability Calculator, DA=Data Analysis, FI=Function Inspector, PV=Python, macro=Macro View
var views = {'is3D': 0,'AV': 1,'SV': 1,'CV': 0,'EV2': 0,'CP': 0,'PC': 0,'DA': 0,'FI': 0,'PV': 0,'macro': 0};

var applet = new GGBApplet(parameters, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');
var applet2 = new GGBApplet(parameters2, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet2.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');

window.onload = function() {
  applet.inject('ggbApplet');
  applet2.inject('ggbApplet2');
};

</script> 
     </div>
</table> 
</body> 
</html> 