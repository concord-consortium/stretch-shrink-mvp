
<!DOCTYPE html>
<html> 
<head> 
<title>GeoGebra and JavaScript</title> 
<script src="https://www.gstatic.com/firebasejs/4.3.0/firebase.js"></script>
<script>
  // Initialize Firebase
  var config = {
    apiKey: "AIzaSyC6xLM2k-aYH62O9UeskD-C1OtFtkM58sw",
    authDomain: "stretch-shrink.firebaseapp.com",
    databaseURL: "https://stretch-shrink.firebaseio.com",
    projectId: "stretch-shrink",
    storageBucket: "stretch-shrink.appspot.com",
    messagingSenderId: "616775738467"
  };
  firebase.initializeApp(config);
</script>
<script src="https://cdn.geogebra.org/apps/deployggb.js"></script>
<link rel="stylesheet" type="text/css" href="style.css">
</head> 
 
<body> 
 
<div id="appContainer"> 

<div id="ggbApplet2"></div>

<div id="ggbApplet"></div>

 
<script type="text/javascript"> 

var objectsToListeners = {},

    app1Loaded = false,
    app2Loaded = false,
    firstLoad = true,

    pointNames = [];

var urlParams;
(window.onpopstate = function () {
    var match,
        pl     = /\+/g,  // Regex for replacing addition symbol with a space
        search = /([^&=]+)=?([^&]*)/g,
        decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
        query  = window.location.search.substring(1);

    urlParams = {};
    while ((match = search.exec(query)))
       urlParams[decode(match[1])] = decode(match[2]);
})();

function ggbOnInit(param) {
  if (param == "ggbApplet") {
    loadGridXML();
  }
  if (param == "ggbApplet2") {
    loadSheetXML();
  }
}

function checkAppsLoaded() {
  if (app1Loaded && app2Loaded && firstLoad) {
    pauseListeners();

    makePolygonsFromSpreadsheet();
    makeMidpoints();
    firstLoad = false;

    restartListeners();
  }
}

function addSheetListeners() {
  if (urlParams.rulesOff) {
    addListener("D3", plotListener);
    addListener("E3", plotListener);
    addListener("D4", plotListener);
    addListener("E4", plotListener);
    addListener("D5", plotListener);
    addListener("E5", plotListener);
    addListener("D6", plotListener);
    addListener("E6", plotListener);
  } else {
    let xCol = "D",
        yCol = "E",
        ruleRow = 2;

    while (true) {
      if (doesShapeExist(xCol, yCol)) {
        addListener(xCol + ruleRow, ruleListener);
        addListener(yCol + ruleRow, ruleListener);
        xCol = nextChar(xCol, 3);
        yCol = nextChar(yCol, 3);
      } else {
        break;
      }
    }
  }
}

// TODO: Combine the logic of these functions
function loadGridXML() {
  let db = firebase.database(),
      sheetRef = db.ref(getBaseUrl() + "/ggbApplet");

  sheetRef.on("value", function(snapshot) {
    if (snapshot.val() && snapshot.val() !== ggbApplet.getXML()) {
      ggbApplet.setXML(snapshot.val());
      if (!firstLoad) {
        // Setting the XML removes listeners, so they must be re-added
        restartListeners();
      }
    }
    app1Loaded = true;
    checkAppsLoaded();
  }, function (errorObject) {
    console.log("The read failed: " + errorObject.code);
    app1Loaded = true;
    checkAppsLoaded();
  });
}

function loadSheetXML() {
  let db = firebase.database(),
      sheetRef = db.ref(getBaseUrl() + "/ggbApplet2");

  sheetRef.on("value", function(snapshot) {
    if (snapshot.val() && snapshot.val() !== ggbApplet2.getXML()) {
      ggbApplet2.setXML(snapshot.val());
      if (!firstLoad) {
        restartListeners();
      }
    }
    addSheetListeners();
    app2Loaded = true;
    checkAppsLoaded();
  }, function (errorObject) {
    console.log("The read failed: " + errorObject.code);
    addSheetListeners();
    app2Loaded = true;
    checkAppsLoaded();
  });
}

function addListener(objName, func) {
  objectsToListeners[objName] = func;
}

function removeListener(objName) {
  objectsToListeners[objName] = null;
}

function pauseListeners() {
  ggbApplet.unregisterUpdateListener("mainListener");
  ggbApplet2.unregisterUpdateListener("mainListener");
}

function restartListeners() {
  pauseListeners();
  ggbApplet.registerUpdateListener("mainListener");
  ggbApplet2.registerUpdateListener("mainListener");
}

function mainListener(objName) {
  if (objectsToListeners[objName]) {
    objectsToListeners[objName](objName);
  }

  // Default listener for modifying main shape
  // TODO: allow for rule-based listeners
  if (objName.length > 1 
      && (objName.startsWith("A") || objName.startsWith("B")) 
      && !isNaN(parseInt(objName.charAt(1)))) {
    sheetListener(objName);
  }
}

function nextChar(c, incAmount = 1) {
  return String.fromCharCode(c.charCodeAt(0) + incAmount);
}

function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
  } : null;
}

function shapeNameToCols(shapeName) {
  let suffixSize = (shapeName.match(/'/g) || []).length;

  return [nextChar("A", suffixSize * 3), nextChar("B", suffixSize * 3)];
}

// Checks if a shape exists by checking if it has a valid pair of coordinates
function doesShapeExist(xCol, yCol) {
  let firstCoords = getRowCoords(3, xCol, yCol);
  return (!isNaN(firstCoords[0]) && !isNaN(firstCoords[1]));
}

function getObjectNamesForRow(rowNum) {
  return ["A" + rowNum, "B" + rowNum];
}

function getRowFromSheetObject(sheetObject) {
  return parseInt(sheetObject.slice(1));
}

function gridObjToSpreadSheetRow(gridObj) {
  let objNum = gridObj.charCodeAt(0),
      objNumDelta = objNum - 65;

  return objNumDelta + 3;
}

function resetSave() {
  let database = firebase.database(),
      ref = database.ref(getBaseUrl()),
      update = {
        ggbApplet: null,
        ggbApplet2: null
      };

  ref.update(update);
  location.reload();
}

function saveState() {
  saveGridXML();
  saveSheetXML();
}

function saveGridXML() {
  let database = firebase.database(),
      ref = database.ref(getBaseUrl()),
      update = {
        ggbApplet: ggbApplet.getXML()
      };

  ref.update(update);
}

function saveSheetXML() {
  let baseXML = ggbApplet2.getXML(),
      parser = new DOMParser(),
      xmlDoc = parser.parseFromString(baseXML,"text/xml"),
      elems = Array.prototype.slice.call(xmlDoc.getElementsByTagName("element"), 0);

  // Remove empty cells or they load with question marks
  elems.forEach(elem => {
    let value = elem.getElementsByTagName("value")[0];
    if (value) {
      if (isNaN(parseInt(value.getAttribute("val")))) {
        elem.parentElement.removeChild(elem);
      }
    }
  });

  let database = firebase.database(),
      ref = database.ref(getBaseUrl()),
      update = {
        ggbApplet2: new XMLSerializer().serializeToString(xmlDoc)
      };

  ref.update(update);
}

function getBaseUrl() {
  let groupId = urlParams.groupId,
      classId = urlParams.classId;

  groupId = isNaN(groupId) ? "default" : groupId;
  classId = isNaN(classId) ? "default" : classId;

  return "/classes/" + classId + "/groups/" + groupId;
}

// Retrieves max coords from the graph
function getMaxCoords(pointSuffix="") {
  let maxX = 0,
      maxY = 0;
  pointNames.forEach(basePointName => {
    let pointName = basePointName + pointSuffix,
        x = ggbApplet.getXcoord(pointName),
        y = ggbApplet.getYcoord(pointName);

    if (x > maxX) {
      maxX = x;
    }
    if (y > maxY) {
      maxY = y;
    }
  });

  return [maxX, maxY];
}

function roundToDecimal(num) {
  return Math.round(num * 100) / 100;
}

function spreadSheetRowToGridObj(spreadsheetRow) {
  return String.fromCharCode(65 + (spreadsheetRow - 3));
}

function getPointCoords(pointName, pointSuffix="") {
  let fullPointName = pointName + pointSuffix;
  return [ggbApplet.getXcoord(fullPointName), ggbApplet.getYcoord(fullPointName)];
}

function getRowCoords(rowNum, xCol = "A", yCol = "B") {
  return [ggbApplet2.getValue(xCol + rowNum), ggbApplet2.getValue(yCol + rowNum)];
}

function arePointsDifferent(point1, point2) {
  return (Math.abs(point1[0] - point2[0]) > 0.01 || Math.abs(point1[1] - point2[1]) > 0.01)
}

function makePolygonsFromSpreadsheet() {
  let xCol = "A",
      yCol = "B",
      suffix = "";

  while (true) {
    if (doesShapeExist(xCol, yCol)) {
      makePolygonFromSpreadsheet(xCol, yCol, suffix);
      xCol = nextChar(xCol, 3);
      yCol = nextChar(yCol, 3);
      suffix += "'";
    } else {
      break;
    }
  }
}

function makePolygonFromSpreadsheet(xColumn, yColumn, pointSuffix = "") {
  let coords = [],
      row = 3,
      pointName = "A",
      polyName = "Poly" + pointSuffix,
      polyString = polyName + " = Polygon(";
  while (true) {
    let xCoord = ggbApplet2.getValue(xColumn + row),
        yCoord = ggbApplet2.getValue(yColumn + row);

    if (!isNaN(xCoord) && !isNaN(yCoord)) {
      ggbApplet.evalCommand(pointName + pointSuffix + " = (" + xCoord + ", " + yCoord + ")");
      polyString += pointName + pointSuffix + ", ";
      if (pointNames.indexOf(pointName) === -1) {
        pointNames.push(pointName);
      }
    } else {
      polyString = polyString.slice(0, polyString.length - 2) + ")";
      ggbApplet.evalCommand(polyString);

      pointNames.forEach(pointName => {
        addListener(pointName, pointListener);
      });

      let hexColor = ggbApplet2.getColor(xColumn + 1),
          rgbColor = hexToRgb(hexColor);
      ggbApplet.setColor(polyName, rgbColor.r, rgbColor.g, rgbColor.b);

      if (!urlParams.rulesOff && pointSuffix.length > 0) {
        addListener(polyName, translateListener);
      }

      break;
    }

    row++;
    pointName = nextChar(pointName);
  }
}

// Assuming that the graph points are correct, draws in new midpoints
function makeMidpoints() {
  let maxCoords = getMaxCoords("'"),
      maxX = maxCoords[0],
      maxY = maxCoords[1];

  ggbApplet.evalCommand("X_MID = (" + maxX/2 + ", " + maxY + ")");
  ggbApplet.evalCommand("X_ZERO = (" + 0 + ", " + maxY + ")");
  ggbApplet.evalCommand("Y_MID = (" + maxX + ", " + maxY/2 + ")");
  ggbApplet.evalCommand("Y_ZERO = (" + maxX + ", " + 0 + ")");
  ggbApplet.evalCommand("XY_MAX = (" + maxX + ", " + maxY + ")");

  ggbApplet.setColor("X_MID", 255, 0, 0);
  ggbApplet.setColor("Y_MID", 255, 0, 0);
  ggbApplet.setColor("XY_MAX", 255, 0, 0);
  ggbApplet.setVisible("X_ZERO", false);
  ggbApplet.setVisible("Y_ZERO", false);

  ggbApplet.evalCommand("TOP_SEG = Segment(X_ZERO, XY_MAX)");
  ggbApplet.evalCommand("RIGHT_SEG = Segment(Y_ZERO, XY_MAX)");
  ggbApplet.setLineStyle("TOP_SEG", 1);
  ggbApplet.setLineStyle("RIGHT_SEG", 1);

  addListener("Y_MID", dilateXListener);
  addListener("X_MID", dilateYListener);
  addListener("XY_MAX", dilateXYListener);
}

function getDilationRules(xCol, yCol) {
  let xRule = ggbApplet2.getValueString(xCol + 2),
      yRule = ggbApplet2.getValueString(yCol + 2),
      xDilation = parseFloat(xRule.slice(0, xRule.indexOf("x"))),
      yDilation = parseFloat(yRule.slice(0, yRule.indexOf("y")));

  return [isNaN(xDilation) ? 1 : xDilation, isNaN(yDilation) ? 1 : yDilation];
}

function getTranslationRules(xCol, yCol) {
  let xRule = ggbApplet2.getValueString(xCol + 2),
      yRule = ggbApplet2.getValueString(yCol + 2),
      translationRegex = /(\-|\+)\s*(\d*\.{0,1}\d+)/,
      xMatch = translationRegex.exec(xRule),
      yMatch = translationRegex.exec(yRule);

  // Grab sign and number for translation rule
  return [xMatch ? parseFloat(xMatch[1] + xMatch[2]) : 0, yMatch ? parseFloat(yMatch[1] + yMatch[2]) : 0];
}

function setCellValue(objName, value) {
  ggbApplet2.evalCommand(objName + " = " + value);
}

// Transforms a point in the graph and corresponding row in spreadsheet. Bases transformation
// off of base position and rules from the spreadsheet.
function transformPoint(pointName) {
  let xCol = "D",
      yCol = "E",
      suffix = "'";

  while (true) {
    if (doesShapeExist(xCol, yCol)) {
      transformPointForShape(pointName, xCol, yCol, suffix);
      xCol = nextChar(xCol, 3);
      yCol = nextChar(yCol, 3);
      suffix += "'";
    } else {
      break;
    }
  }
}

function transformPointForShape(pointName, xCol, yCol, suffix) {
  // Update transformed point coords in spreadsheet
  let dilationRules = getDilationRules(xCol, yCol),
      translationRules = getTranslationRules(xCol, yCol),
      spreadsheetRow = gridObjToSpreadSheetRow(pointName),
      baseCoords = getRowCoords(spreadsheetRow),
      dilatedCoords = [baseCoords[0] * dilationRules[0], baseCoords[1] * dilationRules[1]],
      transformedCoords = [dilatedCoords[0] + translationRules[0], dilatedCoords[1] + translationRules[1]]

  setCellValue(xCol + spreadsheetRow, transformedCoords[0]);
  setCellValue(yCol + spreadsheetRow, transformedCoords[1]);

  // Update transformed points on graph
  ggbApplet.setCoords(pointName + suffix, transformedCoords[0], transformedCoords[1]);
}

function pointListener(objName) {
  pauseListeners();

  console.log("Point listener: " + objName);
  let newCoords = getPointCoords(objName),
      spreadsheetRow = gridObjToSpreadSheetRow(objName),
      oldCoords = getRowCoords(spreadsheetRow);

  // Update point coords in spreadsheet
  setCellValue("A" + spreadsheetRow, newCoords[0]);
  setCellValue("B" + spreadsheetRow, newCoords[1]);

  // Update transformed point coords in spreadsheet
  transformPoint(objName);

  makeMidpoints();
  saveState();

  restartListeners();
}

// TODO: merge these into a single dilate listener
function dilateXListener(objName) {
  pauseListeners();

  console.log("Dilate X listener: " + objName);
  let newX = ggbApplet.getXcoord(objName),
      baseX = getMaxCoords()[0],
      dilation = Math.round(newX / baseX * 100) / 100;

  ggbApplet2.setTextValue("D2", dilation + "x");

  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function dilateYListener(objName) {
  pauseListeners();

  console.log("Dilate Y listener: " + objName);
  let newY = ggbApplet.getYcoord(objName),
      baseY = getMaxCoords()[1],
      dilation = Math.round(newY / baseY * 100) / 100;

  ggbApplet2.setTextValue("E2", dilation + "y");

  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function dilateXYListener(objName) {
  pauseListeners();

  console.log("Dilate XY listener: " + objName);
  let oldDilations = getDilationRules("D", "E"),
      newCoords = getPointCoords(objName),
      baseCoords = getMaxCoords(),
      // We need to scale both dilations by the same amount to maintain aspect ratio
      // Base the scaling amount on the change in the x direction for simplicity
      newXDilation = newCoords[0] / baseCoords[0],
      scaleFactor = newXDilation / oldDilations[0],
      newDilations = [oldDilations[0] * scaleFactor, oldDilations[1] * scaleFactor];

  ggbApplet2.setTextValue("D2", roundToDecimal(newDilations[0]) + "x");
  ggbApplet2.setTextValue("E2", roundToDecimal(newDilations[1]) + "y");

  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function ruleListener(objName) {
  pauseListeners();

  console.log("Rule listener: " + objName);
  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function sheetListener(objName) {
  pauseListeners();

  console.log("Sheet listener: " + objName);
  let row = getRowFromSheetObject(objName),
      rowCoords = getRowCoords(row);

  if (!isNaN(rowCoords[0]) && !isNaN(rowCoords[1])) {
    let rowObjects = getObjectNamesForRow(row),
        pointName = spreadSheetRowToGridObj(row);

    // Transform and draw the new shape
    transformPoint(pointName);
    makePolygonsFromSpreadsheet();
    makeMidpoints();

    saveState();
  }

  restartListeners();
}

function translateListener(objName) {
  pauseListeners();

  console.log("Translate listener: " + objName);
  // Pick a representative point from the transformed shape to find translation rules
  let sampleRow = 3,
      baseObj = spreadSheetRowToGridObj(sampleRow),
      baseCoords = getPointCoords(baseObj),
      cols = shapeNameToCols(objName),
      dilationRules = getDilationRules(cols[0], cols[1]),
      dilatedCoords = [baseCoords[0] * dilationRules[0], baseCoords[1] * dilationRules[1]],

      transformedObj = baseObj + objName.slice(objName.indexOf("'")),
      transformedCoords = getPointCoords(transformedObj),
      newTranslationRules = [Math.round((transformedCoords[0] - dilatedCoords[0]) * 100) / 100, 
                             Math.round((transformedCoords[1] - dilatedCoords[1]) * 100) / 100];

  ggbApplet2.setTextValue(cols[0] + 2, newTranslationRules[0] >= 0 
                                  ? dilationRules[0] + "x + " + newTranslationRules[0]
                                  : dilationRules[0] + "x - " + Math.abs(newTranslationRules[0]));
  ggbApplet2.setTextValue(cols[1] + 2, newTranslationRules[1] >= 0 
                                  ? dilationRules[1] + "y + " + newTranslationRules[1]
                                  : dilationRules[1] + "y - " + Math.abs(newTranslationRules[1]));

  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function plotListener(objName) {
  pauseListeners();
  makePolygonsFromSpreadsheet();
  restartListeners();
}

var parameters = {
"id": "ggbApplet",
"width":1000,
"height":750,
"showMenuBar":false,
"showAlgebraInput":false,
"showToolBar":false,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id": urlParams.gridId ? urlParams.gridId : "c23xKskj"};


var parameters2 = {
"id": "ggbApplet2",
"width":600,
"height":750,
"showMenuBar":false,
"showAlgebraInput":false,
"showToolBar":false,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id": urlParams.sheetId ? urlParams.sheetId : "uKg8Y9WS",
};

// is3D=is 3D applet using 3D view, AV=Algebra View, SV=Spreadsheet View, CV=CAS View, EV2=Graphics View 2, CP=Construction Protocol, PC=Probability Calculator, DA=Data Analysis, FI=Function Inspector, PV=Python, macro=Macro View
var views = {'is3D': 0,'AV': 1,'SV': 1,'CV': 0,'EV2': 0,'CP': 0,'PC': 0,'DA': 0,'FI': 0,'PV': 0,'macro': 0};

var applet = new GGBApplet(parameters, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');
var applet2 = new GGBApplet(parameters2, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet2.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');

window.onload = function() {
  applet.inject('ggbApplet');
  applet2.inject('ggbApplet2');
};

</script> 
</div>
<button onclick="resetSave()">Reset to Default</button>
</table> 
</body> 
</html> 