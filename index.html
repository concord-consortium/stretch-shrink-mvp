
<!DOCTYPE html>
<html> 
<head> 
<title>GeoGebra and JavaScript</title> 
<script src="https://cdn.geogebra.org/apps/deployggb.js"></script>

</head> 
 
<body> 
 
<div> 

<div id="ggbApplet"></div>

<div id="ggbApplet2"></div>

 
<script type="text/javascript"> 

  var app1Loaded = false,
      app2Loaded = false,

      pointNames = [];

function ggbOnInit(param) {
  if (param == "ggbApplet") {
    app1Loaded = true;
  }
  if (param == "ggbApplet2") {
    console.log("Setting listeners");
    ggbApplet2.registerObjectUpdateListener("A3", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("B3", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("A4", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("B4", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("A5", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("B5", "sheetListener");
    app2Loaded = true;
  }

  if (app1Loaded && app2Loaded) {
    makePolygonFromSpreadsheet();
    makeMidpoints();
  }
}

function nextChar(c) {
  return String.fromCharCode(c.charCodeAt(0) + 1);
}

function gridObjToSpreadSheetRow(gridObj) {
  let objNum = gridObj.charCodeAt(0),
      objNumDelta = objNum - 65;

  return objNumDelta + 3;
}

function getMaxCoords() {
  let maxX = 0,
      maxY = 0;
  pointNames.forEach(pointName => {
    let x = ggbApplet.getXcoord(pointName),
        y = ggbApplet.getYcoord(pointName);

    if (x > maxX) {
      maxX = x;
    }
    if (y > maxY) {
      maxY = y;
    }
  });

  return [maxX, maxY];
}

function spreadSheetRowToGridObj(spreadsheetRow) {
  return String.fromCharCode(65 + (spreadsheetRow - 3));
}

function getPointCoords(pointName) {
  return [ggbApplet.getXcoord(pointName), ggbApplet.getYcoord(pointName)];
}

function getRowCoords(rowNum) {
  return [ggbApplet2.getValue("A" + rowNum), ggbApplet2.getValue("B" + rowNum)];
}

function arePointsDifferent(point1, point2) {
  return (Math.abs(point1[0] - point2[0]) > 0.01 || Math.abs(point1[1] - point2[1]) > 0.01)
}

function makePolygonFromSpreadsheet() {
  let coords = [],
      row = 3,
      pointName = "A",
      polyString = "Poly = Polygon(";
  while (true) {
    let xCoord = ggbApplet2.getValue("A" + row),
        yCoord = ggbApplet2.getValue("B" + row);

    if (!isNaN(xCoord) && !isNaN(yCoord)) {
      ggbApplet.evalCommand(pointName + " = (" + xCoord + ", " + yCoord + ")");
      polyString += pointName + ", ";
      pointNames.push(pointName);
    } else {
      polyString = polyString.slice(0, polyString.length - 2) + ")";
      ggbApplet.evalCommand(polyString);

      pointNames.forEach(pointName => {
        ggbApplet.registerObjectUpdateListener(pointName, "pointListener");
      });

      break;
    }

    row++;
    pointName = nextChar(pointName);
  }
}

function makeMidpoints() {
  let maxCoords = getMaxCoords(),
      maxX = maxCoords[0],
      maxY = maxCoords[1];

  ggbApplet.evalCommand("X_MID = (" + maxX/2 + ", " + maxY + ")");
  ggbApplet.evalCommand("X_ZERO = (" + 0 + ", " + maxY + ")");
  ggbApplet.evalCommand("Y_MID = (" + maxX + ", " + maxY/2 + ")");
  ggbApplet.evalCommand("Y_ZERO = (" + maxX + ", " + 0 + ")");
  ggbApplet.evalCommand("XY_MAX = (" + maxX + ", " + maxY + ")");

  ggbApplet.setColor("X_MID", 255, 0, 0);
  ggbApplet.setColor("Y_MID", 255, 0, 0);
  ggbApplet.setColor("XY_MAX", 255, 0, 0);
  ggbApplet.setVisible("X_ZERO", false);
  ggbApplet.setVisible("Y_ZERO", false);

  ggbApplet.evalCommand("TOP_SEG = Segment(X_ZERO, XY_MAX)");
  ggbApplet.evalCommand("RIGHT_SEG = Segment(Y_ZERO, XY_MAX)");
  ggbApplet.setLineStyle("TOP_SEG", 1);
  ggbApplet.setLineStyle("RIGHT_SEG", 1);

  ggbApplet.registerObjectUpdateListener("Y_MID", "dilateXListener");
  ggbApplet.registerObjectUpdateListener("X_MID", "dilateYListener");
}
 
function pointListener(objName) {
  console.log("echo");
  let newX = ggbApplet.getXcoord(objName),
      newY = ggbApplet.getYcoord(objName),
      row = gridObjToSpreadSheetRow(objName);

  let newCoords = getPointCoords(objName),
      spreadsheetRow = gridObjToSpreadSheetRow(objName),
      oldCoords = getRowCoords(spreadsheetRow);

  if (arePointsDifferent(newCoords, oldCoords)) {
    ggbApplet2.setValue("A" + row, newX);
    ggbApplet2.setValue("B" + row, newY);

    makeMidpoints();
  }
}

// TODO: merge these into a single dilate listener
function dilateXListener(objName) {
  let newX = ggbApplet.getXcoord(objName),
      oldX = getMaxCoords()[0],
      dilation = newX / oldX;

  pointNames.forEach(pointName => {
    let xCoord = ggbApplet.getXcoord(pointName),
        yCoord = ggbApplet.getYcoord(pointName),
        row = gridObjToSpreadSheetRow(pointName);

    ggbApplet2.setValue("A" + row, xCoord * dilation);
  });
}

function dilateYListener(objName) {
  let newY = ggbApplet.getYcoord(objName),
      oldY = getMaxCoords()[1],
      dilation = newY / oldY;

  pointNames.forEach(pointName => {
    let xCoord = ggbApplet.getXcoord(pointName),
        yCoord = ggbApplet.getYcoord(pointName),
        row = gridObjToSpreadSheetRow(pointName);

    ggbApplet2.setValue("B" + row, yCoord * dilation);
  });
}

function sheetListener(objName) {
  console.log("echo");
  let rowNum = parseInt(objName.slice(1)),
      gridObj = spreadSheetRowToGridObj(rowNum),
      oldCoords = getPointCoords(gridObj),
      newCoords = getRowCoords(rowNum);

  if (arePointsDifferent(oldCoords, newCoords)) {
    ggbApplet.setCoords(gridObj, newCoords[0], newCoords[1]);

    makeMidpoints();
  }
}

var parameters = {
"id": "ggbApplet",
"width":1000,
"height":750,
"showMenuBar":true,
"showAlgebraInput":false,
"showToolBar":true,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id":"c23xKskj"};


var parameters2 = {
"id": "ggbApplet2",
"width":1000,
"height":750,
"showMenuBar":true,
"showAlgebraInput":false,
"showToolBar":true,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id":"uKg8Y9WS",
};

// is3D=is 3D applet using 3D view, AV=Algebra View, SV=Spreadsheet View, CV=CAS View, EV2=Graphics View 2, CP=Construction Protocol, PC=Probability Calculator, DA=Data Analysis, FI=Function Inspector, PV=Python, macro=Macro View
var views = {'is3D': 0,'AV': 1,'SV': 1,'CV': 0,'EV2': 0,'CP': 0,'PC': 0,'DA': 0,'FI': 0,'PV': 0,'macro': 0};

var applet = new GGBApplet(parameters, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');
var applet2 = new GGBApplet(parameters2, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet2.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');

window.onload = function() {
  applet.inject('ggbApplet');
  applet2.inject('ggbApplet2');
};

</script> 
     </div>
</table> 
</body> 
</html> 