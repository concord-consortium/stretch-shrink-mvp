
<!DOCTYPE html>
<html> 
<head> 
<title>GeoGebra and JavaScript</title> 
<script src="https://www.gstatic.com/firebasejs/4.3.0/firebase.js"></script>
<script>
  // Initialize Firebase
  var config = {
    apiKey: "AIzaSyC6xLM2k-aYH62O9UeskD-C1OtFtkM58sw",
    authDomain: "stretch-shrink.firebaseapp.com",
    databaseURL: "https://stretch-shrink.firebaseio.com",
    projectId: "stretch-shrink",
    storageBucket: "stretch-shrink.appspot.com",
    messagingSenderId: "616775738467"
  };
  firebase.initializeApp(config);
</script>
<script src="https://cdn.geogebra.org/apps/deployggb.js"></script>
<link rel="stylesheet" type="text/css" href="style.css">
</head> 
 
<body> 
 
<div id="appContainer"> 

<div id="ggbApplet2"></div>

<div id="ggbApplet"></div>

 
<script type="text/javascript"> 

var objectsToListeners = {},

    app1Loaded = false,
    app2Loaded = false,
    firstLoad = true,

    pointNames = [];

var urlParams;
(window.onpopstate = function () {
    var match,
        pl     = /\+/g,  // Regex for replacing addition symbol with a space
        search = /([^&=]+)=?([^&]*)/g,
        decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
        query  = window.location.search.substring(1);

    urlParams = {};
    while ((match = search.exec(query)))
       urlParams[decode(match[1])] = decode(match[2]);
})();

function ggbOnInit(param) {
  if (param == "ggbApplet") {
    loadGridXML();
  }
  if (param == "ggbApplet2") {
    loadSheetXML();
  }
}

function checkAppsLoaded() {
  if (app1Loaded && app2Loaded && firstLoad) {
    pauseListeners();

    makePolygonsFromSpreadsheet();
    makeMidpoints();
    firstLoad = false;

    restartListeners();
  }
}

// TODO: Combine the logic of these functions
function loadGridXML() {
  let db = firebase.database(),
      sheetRef = db.ref(getBaseUrl() + "/ggbApplet");

  sheetRef.on("value", function(snapshot) {
    if (snapshot.val() && snapshot.val() !== ggbApplet.getXML()) {
      ggbApplet.setXML(snapshot.val());
      if (!firstLoad) {
        // Setting the XML removes listeners, so they must be re-added
        restartListeners();
      }
    }
    app1Loaded = true;
    checkAppsLoaded();
  }, function (errorObject) {
    console.log("The read failed: " + errorObject.code);
    app1Loaded = true;
    checkAppsLoaded();
  });
}

function loadSheetXML() {
  let db = firebase.database(),
      sheetRef = db.ref(getBaseUrl() + "/ggbApplet2");

  sheetRef.on("value", function(snapshot) {
    if (snapshot.val() && snapshot.val() !== ggbApplet2.getXML()) {
      ggbApplet2.setXML(snapshot.val());
      if (!firstLoad) {
        restartListeners();
      }
    }
    app2Loaded = true;
    checkAppsLoaded();
  }, function (errorObject) {
    console.log("The read failed: " + errorObject.code);
    app2Loaded = true;
    checkAppsLoaded();
  });
}

function addListener(objName, func) {
  objectsToListeners[objName] = func;
}

function removeListener(objName) {
  objectsToListeners[objName] = null;
}

function pauseListeners() {
  ggbApplet.unregisterUpdateListener("gridListener");
  ggbApplet2.unregisterUpdateListener("sheetListener");
}

function restartListeners() {
  pauseListeners();
  ggbApplet.registerUpdateListener("gridListener");
  ggbApplet2.registerUpdateListener("sheetListener");
}

function sheetListener(objName) {
  if (urlParams.rulesOff) {
    if (objName.startsWith("C")) {
      plotListener(objName);
    }
  } else {
    let rowNum = getRowFromSheetObject(objName);
    if (rowNum == 1) {
      makeButtons();
    } else if (rowNum === 2) {
      ruleListener(objName);
    } else if (rowNum >= 3) {
      rowListener(objName);
    }
  }
}

function gridListener(objName) {
  if (objectsToListeners[objName]) {
    objectsToListeners[objName](objName);
  }
}

function nextChar(c, incAmount = 1) {
  return String.fromCharCode(c.charCodeAt(0) + incAmount);
}

function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
  } : null;
}

function shapeNameToCol(shapeName) {
  let suffixSize = (shapeName.match(/'/g) || []).length;

  return nextChar("B", suffixSize);
}

// Checks if a shape exists by checking if it has a rule
function doesShapeExist(col) {
  return ggbApplet2.getValueString(col + 2) !== "";
}

function getRowFromSheetObject(sheetObject) {
  return parseInt(sheetObject.slice(1));
}

function gridObjToSpreadSheetRow(gridObj) {
  let objNum = gridObj.charCodeAt(0),
      objNumDelta = objNum - 65;

  return objNumDelta + 3;
}

function resetSave() {
  let database = firebase.database(),
      ref = database.ref(getBaseUrl()),
      update = {
        ggbApplet: null,
        ggbApplet2: null
      };

  ref.update(update);
  location.reload();
}

function toggleBaseComparison() {
  pauseListeners();

  if (!ggbApplet.getVisible("PolyCopy")) {
    let copyPolyCommand = "PolyCopy = Polygon("
    for (let i = 0; i < pointNames.length - 1; i++) {
      let coords = getPointCoords(pointNames[i]);
      copyPolyCommand += "(" + coords[0] + ", " + coords[1] + "), ";
    }

    let lastCoords = getPointCoords(pointNames[pointNames.length - 1]);
    copyPolyCommand += "(" + lastCoords[0] + ", " + lastCoords[1] + "))";

    ggbApplet.evalCommand(copyPolyCommand);
    let color = hexToRgb(ggbApplet.getColor("Poly"));
    ggbApplet.setColor("PolyCopy", color.r, color.g, color.b);
    ggbApplet.setVisible("PolyCopy", true);
  } else {
    ggbApplet.setVisible("PolyCopy", false);
  }

  restartListeners();
}

function saveState() {
  saveGridXML();
  saveSheetXML();
}

function saveGridXML() {
  let database = firebase.database(),
      ref = database.ref(getBaseUrl()),
      update = {
        ggbApplet: ggbApplet.getXML()
      };

  ref.update(update);
}

function saveSheetXML() {
  let baseXML = ggbApplet2.getXML(),
      parser = new DOMParser(),
      xmlDoc = parser.parseFromString(baseXML,"text/xml"),
      elems = Array.prototype.slice.call(xmlDoc.getElementsByTagName("element"), 0);

  // Remove empty cells or they load with question marks
  elems.forEach(elem => {
    let value = elem.getElementsByTagName("value")[0];
    if (value) {
      if (isNaN(parseInt(value.getAttribute("val")))) {
        elem.parentElement.removeChild(elem);
      }
    }
  });

  let database = firebase.database(),
      ref = database.ref(getBaseUrl()),
      update = {
        ggbApplet2: new XMLSerializer().serializeToString(xmlDoc)
      };

  ref.update(update);
}

function getBaseUrl() {
  let groupId = urlParams.groupId,
      classId = urlParams.classId;

  groupId = isNaN(groupId) ? "default" : groupId;
  classId = isNaN(classId) ? "default" : classId;

  return "/classes/" + classId + "/groups/" + groupId;
}

// Retrieves max coords from the graph
function getMaxCoords(pointSuffix="") {
  let maxX = 0,
      maxY = 0;
  pointNames.forEach(basePointName => {
    let pointName = basePointName + pointSuffix,
        x = ggbApplet.getXcoord(pointName),
        y = ggbApplet.getYcoord(pointName);

    if (x > maxX) {
      maxX = x;
    }
    if (y > maxY) {
      maxY = y;
    }
  });

  return [maxX, maxY];
}

function roundToDecimal(num) {
  return Math.round(num * 100) / 100;
}

function spreadSheetRowToGridObj(spreadsheetRow) {
  return String.fromCharCode(65 + (spreadsheetRow - 3));
}

function getPointCoords(pointName, pointSuffix="") {
  let fullPointName = pointName + pointSuffix;
  return [ggbApplet.getXcoord(fullPointName), ggbApplet.getYcoord(fullPointName)];
}

function getRowCoords(rowNum, col="B") {
  let coordRegex = /(\-?\d*\.?\d+),\s*(\-?\d*\.?\d+)/g,
      point = ggbApplet2.getValueString(col + rowNum),
      matches = coordRegex.exec(point) || [null, null],
      xCoord = matches[1],
      yCoord = matches[2];

  return [xCoord, yCoord];
}

function makeButtons() {
  let col = "C",
      suffix = "'",
      buttonsDiv = document.getElementById("visiblity-buttons");

  buttonsDiv.innerHTML = "";
  while (true) {
    if (doesShapeExist(col)) {
      let shapeName = ggbApplet2.getValueString(col + 1),
          shapeColor = ggbApplet2.getColor(col + 1),
          button = document.createElement("button");

      button.onclick = (function(suffix) {return function() {
        pauseListeners();
        let gridShapeName = "Poly" + suffix,
            visibility = ggbApplet.getVisible(gridShapeName);

        ggbApplet.setVisible(gridShapeName, !visibility);
        pointNames.forEach(name => {
          ggbApplet.setVisible(name + suffix, !visibility);
        });
        restartListeners();
      }}(suffix));

      button.innerText = "Toggle " + shapeName + " visibility";
      button.style.color = shapeColor;
      let buttonsDiv = document.getElementById("visiblity-buttons");
      buttonsDiv.appendChild(button);
      col = nextChar(col);
      suffix += "'";
    } else {
      break;
    }
  }
}

function makePolygonsFromSpreadsheet() {
  let col = "B",
      suffix = "";

  while (true) {
    if (doesShapeExist(col)) {
      makePolygonFromSpreadsheet(col, suffix);
      col = nextChar(col);
      suffix += "'";
    } else {
      break;
    }
  }
  makeButtons();
}

function makePolygonFromSpreadsheet(col, pointSuffix = "") {
  let coords = [],
      row = 3,
      pointName = "A",
      polyName = "Poly" + pointSuffix,
      polyString = polyName + " = Polygon(";
  while (true) {
    let coords = getRowCoords(row, col)
        xCoord = coords[0],
        yCoord = coords[1]

    if (!isNaN(xCoord) && !isNaN(yCoord)) {
      ggbApplet.evalCommand(pointName + pointSuffix + " = (" + xCoord + ", " + yCoord + ")");
      polyString += pointName + pointSuffix + ", ";
      if (pointNames.indexOf(pointName) === -1) {
        pointNames.push(pointName);
      }
      ggbApplet.setLabelVisible(pointName + pointSuffix, true);
    } else {
      polyString = polyString.slice(0, polyString.length - 2) + ")";
      ggbApplet.evalCommand(polyString);

      pointNames.forEach(pointName => {
        addListener(pointName, pointListener);
      });

      let hexColor = ggbApplet2.getColor(col + 1),
          rgbColor = hexToRgb(hexColor);
      ggbApplet.setColor(polyName, rgbColor.r, rgbColor.g, rgbColor.b);

      if (!urlParams.rulesOff && pointSuffix.length > 0) {
        addListener(polyName, translateListener);
      }

      break;
    }

    row++;
    pointName = nextChar(pointName);
  }
}

// Assuming that the graph points are correct, draws in new midpoints
function makeMidpoints() {
  let maxCoords = getMaxCoords("'"),
      maxX = maxCoords[0],
      maxY = maxCoords[1];

  ggbApplet.evalCommand("X_MID = (" + maxX/2 + ", " + maxY + ")");
  ggbApplet.evalCommand("X_ZERO = (" + 0 + ", " + maxY + ")");
  ggbApplet.evalCommand("Y_MID = (" + maxX + ", " + maxY/2 + ")");
  ggbApplet.evalCommand("Y_ZERO = (" + maxX + ", " + 0 + ")");
  ggbApplet.evalCommand("XY_MAX = (" + maxX + ", " + maxY + ")");

  ggbApplet.setColor("X_MID", 255, 0, 0);
  ggbApplet.setColor("Y_MID", 255, 0, 0);
  ggbApplet.setColor("XY_MAX", 255, 0, 0);
  ggbApplet.setVisible("X_ZERO", false);
  ggbApplet.setVisible("Y_ZERO", false);

  ggbApplet.evalCommand("TOP_SEG = Segment(X_ZERO, XY_MAX)");
  ggbApplet.evalCommand("RIGHT_SEG = Segment(Y_ZERO, XY_MAX)");
  ggbApplet.setLineStyle("TOP_SEG", 1);
  ggbApplet.setLineStyle("RIGHT_SEG", 1);

  addListener("Y_MID", dilateXListener);
  addListener("X_MID", dilateYListener);
  addListener("XY_MAX", dilateXYListener);
}

function getDilationRules(col) {
  let rulePair = ggbApplet2.getValueString(col + 2),
      xRegex = /(\-?\d*\.?\d+)x/g,
      yRegex = /(\-?\d*\.?\d+)y/g,
      xMatch = xRegex.exec(rulePair),
      yMatch = yRegex.exec(rulePair),
      xDilation = xMatch ? parseFloat(xMatch[1]) : 1,
      yDilation = yMatch ? parseFloat(yMatch[1]) : 1;

  return [xDilation, yDilation];
}

function getTranslationRules(col) {
  let rulePair = ggbApplet2.getValueString(col + 2),
      xRegex = /x\s*(\-|\+)\s*(\d*\.?\d+)/g,
      yRegex = /y\s*(\-|\+)\s*(\d*\.?\d+)/g,
      xMatch = xRegex.exec(rulePair),
      yMatch = yRegex.exec(rulePair),
      // Grab the parsed sign and number for translation rule
      xTranslation = xMatch ? parseFloat(xMatch[1] + xMatch[2]) : 0,
      yTranslation = yMatch ? parseFloat(yMatch[1] + yMatch[2]) : 0;

  return [xTranslation, yTranslation];
}

function setCellCoordinateValue(objName, xCoord, yCoord) {
  ggbApplet2.evalCommand(objName + " = (" + xCoord + ", " + yCoord + ")");
  ggbApplet2.setColor(objName, 0, 0, 0);
}

// Transforms a point in the graph and corresponding row in spreadsheet. Bases transformation
// off of base position and rules from the spreadsheet.
function transformPoint(pointName) {
  let col = "C",
      suffix = "'";

  while (true) {
    if (doesShapeExist(col)) {
      transformPointForShape(pointName, col, suffix);
      col = nextChar(col);
      suffix += "'";
    } else {
      break;
    }
  }
}

function transformPointForShape(pointName, col, suffix) {
  // Update transformed point coords in spreadsheet
  let dilationRules = getDilationRules(col),
      translationRules = getTranslationRules(col),
      spreadsheetRow = gridObjToSpreadSheetRow(pointName),
      baseCoords = getRowCoords(spreadsheetRow),
      dilatedCoords = [baseCoords[0] * dilationRules[0], baseCoords[1] * dilationRules[1]],
      transformedCoords = [dilatedCoords[0] + translationRules[0], dilatedCoords[1] + translationRules[1]]

  setCellCoordinateValue(col + spreadsheetRow, transformedCoords[0], transformedCoords[1]);

  // Update transformed points on graph
  ggbApplet.setCoords(pointName + suffix, transformedCoords[0], transformedCoords[1]);
}

function pointListener(objName) {
  pauseListeners();

  console.log("Point listener: " + objName);
  let newCoords = getPointCoords(objName),
      spreadsheetRow = gridObjToSpreadSheetRow(objName),
      oldCoords = getRowCoords(spreadsheetRow);

  // Update point coords in spreadsheet
  setCellCoordinateValue("B" + spreadsheetRow, newCoords[0], newCoords[1]);

  // Update transformed point coords in spreadsheet
  transformPoint(objName);

  makeMidpoints();
  saveState();

  restartListeners();
}

// TODO: merge these into a single dilate listener
function dilateXListener(objName) {
  pauseListeners();

  console.log("Dilate X listener: " + objName);
  let newX = ggbApplet.getXcoord(objName),
      baseX = getMaxCoords()[0],
      newXDilation = Math.round(newX / baseX * 100) / 100,
      yDilation = getDilationRules("C")[1];

  ggbApplet2.setTextValue("C2", "(" + newXDilation + "x, " + yDilation + "y)");

  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function dilateYListener(objName) {
  pauseListeners();

  console.log("Dilate Y listener: " + objName);
  let newY = ggbApplet.getYcoord(objName),
      baseY = getMaxCoords()[1],
      newYDilation = Math.round(newY / baseY * 100) / 100,
      xDilation = getDilationRules("C")[0];

  ggbApplet2.setTextValue("C2", "(" + xDilation + "x, " + newYDilation + "y)");

  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function dilateXYListener(objName) {
  pauseListeners();

  console.log("Dilate XY listener: " + objName);
  let oldDilations = getDilationRules("C"),
      newCoords = getPointCoords(objName),
      baseCoords = getMaxCoords(),
      // We need to scale both dilations by the same amount to maintain aspect ratio
      // Base the scaling amount on the change in the x direction for simplicity
      newXDilation = newCoords[0] / baseCoords[0],
      scaleFactor = newXDilation / oldDilations[0],
      newDilations = [oldDilations[0] * scaleFactor, oldDilations[1] * scaleFactor];

  ggbApplet2.setTextValue("C2", "(" + roundToDecimal(newDilations[0]) + "x, " + roundToDecimal(newDilations[1]) + "y)");

  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function ruleListener(objName) {
  pauseListeners();

  console.log("Rule listener: " + objName);
  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function rowListener(objName) {
  pauseListeners();

  console.log("Row listener: " + objName);
  let row = getRowFromSheetObject(objName),
      rowCoords = getRowCoords(row, "B");

  if (!isNaN(rowCoords[0]) && !isNaN(rowCoords[1])) {
    let pointName = spreadSheetRowToGridObj(row);

    // Transform and draw the new shape
    transformPoint(pointName);
    makePolygonsFromSpreadsheet();
    makeMidpoints();

    saveState();
  }

  restartListeners();
}

function translateListener(objName) {
  pauseListeners();

  console.log("Translate listener: " + objName);
  // Pick a representative point from the transformed shape to find translation rules
  let sampleRow = 3,
      baseObj = spreadSheetRowToGridObj(sampleRow),
      baseCoords = getPointCoords(baseObj),
      col = shapeNameToCol(objName),
      dilationRules = getDilationRules(col),
      dilatedCoords = [baseCoords[0] * dilationRules[0], baseCoords[1] * dilationRules[1]],

      transformedObj = baseObj + objName.slice(objName.indexOf("'")),
      transformedCoords = getPointCoords(transformedObj),
      newTranslationRules = [Math.round((transformedCoords[0] - dilatedCoords[0]) * 100) / 100, 
                             Math.round((transformedCoords[1] - dilatedCoords[1]) * 100) / 100],

      xTransform = newTranslationRules[0] >= 0 
                    ? dilationRules[0] + "x + " + newTranslationRules[0]
                    : dilationRules[0] + "x - " + Math.abs(newTranslationRules[0]),
      yTransform = newTranslationRules[1] >= 0 
                    ? dilationRules[1] + "y + " + newTranslationRules[1]
                    : dilationRules[1] + "y - " + Math.abs(newTranslationRules[1]);

  ggbApplet2.setTextValue(col + 2, "(" + xTransform + ", " + yTransform + ")");

  pointNames.forEach(pointName => {
    transformPoint(pointName);
  });

  makeMidpoints();
  saveState();

  restartListeners();
}

function plotListener(objName) {
  pauseListeners();
  makePolygonsFromSpreadsheet();
  restartListeners();
}

var parameters = {
"id": "ggbApplet",
"width":900,
"height":750,
"showMenuBar":false,
"showAlgebraInput":false,
"showToolBar":true,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id": urlParams.gridId ? urlParams.gridId : "c23xKskj"};


var parameters2 = {
"id": "ggbApplet2",
"width":700,
"height":750,
"showMenuBar":false,
"showAlgebraInput":false,
"showToolBar":true,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id": urlParams.sheetId ? urlParams.sheetId : "j63fSPAa",
};

// is3D=is 3D applet using 3D view, AV=Algebra View, SV=Spreadsheet View, CV=CAS View, EV2=Graphics View 2, CP=Construction Protocol, PC=Probability Calculator, DA=Data Analysis, FI=Function Inspector, PV=Python, macro=Macro View
var views = {'is3D': 0,'AV': 1,'SV': 1,'CV': 0,'EV2': 0,'CP': 0,'PC': 0,'DA': 0,'FI': 0,'PV': 0,'macro': 0};

var applet = new GGBApplet(parameters, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');
var applet2 = new GGBApplet(parameters2, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet2.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');

window.onload = function() {
  applet.inject('ggbApplet');
  applet2.inject('ggbApplet2');
};

</script> 
</div>
<div id="buttons">
  <button onclick="resetSave()">Reset to Default</button>
  <button onclick="toggleBaseComparison()" style="color: red">Toggle Comparison Mug</button>
  <div id="visiblity-buttons"></div>
</div>
</table> 
</body> 
</html> 