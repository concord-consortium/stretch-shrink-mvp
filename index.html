
<!DOCTYPE html>
<html> 
<head> 
<title>GeoGebra and JavaScript</title> 
<script src="https://cdn.geogebra.org/apps/deployggb.js"></script>

</head> 
 
<body> 
 
<div> 

<div id="ggbApplet"></div>

<div id="ggbApplet2"></div>

 
<script type="text/javascript"> 

  var lockNames = ["sheetListener", "pointListener", "dilationListener", "sheetTransformationListener", "ruleListener"],
      availableLocks = ["sheetListener", "pointListener", "dilationListener", "sheetTransformationListener", "ruleListener"],

      app1Loaded = false,
      app2Loaded = false,

      pointNames = [];

function ggbOnInit(param) {
  if (param == "ggbApplet") {
    app1Loaded = true;
  }
  if (param == "ggbApplet2") {
    console.log("Setting listeners");
    ggbApplet2.registerObjectUpdateListener("A3", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("B3", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("A4", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("B4", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("A5", "sheetListener");
    ggbApplet2.registerObjectUpdateListener("B5", "sheetListener");

    ggbApplet2.registerObjectUpdateListener("D3", "sheetTransformationListener");
    ggbApplet2.registerObjectUpdateListener("E3", "sheetTransformationListener");
    ggbApplet2.registerObjectUpdateListener("D4", "sheetTransformationListener");
    ggbApplet2.registerObjectUpdateListener("E4", "sheetTransformationListener");
    ggbApplet2.registerObjectUpdateListener("D5", "sheetTransformationListener");
    ggbApplet2.registerObjectUpdateListener("E5", "sheetTransformationListener");

    ggbApplet2.registerObjectUpdateListener("D2", "ruleListener");
    ggbApplet2.registerObjectUpdateListener("E2", "ruleListener")
    app2Loaded = true;
  }

  if (app1Loaded && app2Loaded) {
    makePolygonFromSpreadsheet("A", "B");
    makePolygonFromSpreadsheet("D", "E", "'");
    makeMidpoints();
  }
}

function lock(lockName) {
  let lockIndex = availableLocks.indexOf(lockName);
  if (lockIndex > -1) {
    availableLocks.splice(lockIndex, 1);
  }
}

function unlock(lockName) {
  availableLocks.push(lockName);
}

function lockAll() {
  availableLocks = [];
}

function unlockAll() {
  availableLocks = lockNames.slice(0);
}

function isLocked(lockName) {
  return availableLocks.indexOf(lockName) === -1;
}

function nextChar(c) {
  return String.fromCharCode(c.charCodeAt(0) + 1);
}

function gridObjToSpreadSheetRow(gridObj) {
  let objNum = gridObj.charCodeAt(0),
      objNumDelta = objNum - 65;

  return objNumDelta + 3;
}

function getMaxCoords(pointSuffix="") {
  let maxX = 0,
      maxY = 0;
  pointNames.forEach(basePointName => {
    let pointName = basePointName + pointSuffix,
        x = ggbApplet.getXcoord(pointName),
        y = ggbApplet.getYcoord(pointName);

    if (x > maxX) {
      maxX = x;
    }
    if (y > maxY) {
      maxY = y;
    }
  });

  return [maxX, maxY];
}

function spreadSheetRowToGridObj(spreadsheetRow) {
  return String.fromCharCode(65 + (spreadsheetRow - 3));
}

function getPointCoords(pointName, pointSuffix="") {
  let fullPointName = pointName + pointSuffix;
  return [ggbApplet.getXcoord(fullPointName), ggbApplet.getYcoord(fullPointName)];
}

function getRowCoords(rowNum, xCol = "A", yCol = "B") {
  return [ggbApplet2.getValue(xCol + rowNum), ggbApplet2.getValue(yCol + rowNum)];
}

function arePointsDifferent(point1, point2) {
  return (Math.abs(point1[0] - point2[0]) > 0.01 || Math.abs(point1[1] - point2[1]) > 0.01)
}

function makePolygonFromSpreadsheet(xColumn, yColumn, pointSuffix = "") {
  let coords = [],
      row = 3,
      pointName = "A",
      polyString = "Poly" + pointSuffix + " = Polygon(";
  while (true) {
    let xCoord = ggbApplet2.getValue(xColumn + row),
        yCoord = ggbApplet2.getValue(yColumn + row);

    if (!isNaN(xCoord) && !isNaN(yCoord)) {
      ggbApplet.evalCommand(pointName + pointSuffix + " = (" + xCoord + ", " + yCoord + ")");
      polyString += pointName + pointSuffix + ", ";
      if (pointNames.indexOf(pointName) === -1) {
        pointNames.push(pointName);
      }
    } else {
      polyString = polyString.slice(0, polyString.length - 2) + ")";
      ggbApplet.evalCommand(polyString);

      pointNames.forEach(pointName => {
        ggbApplet.registerObjectUpdateListener(pointName, "pointListener");
      });

      break;
    }

    row++;
    pointName = nextChar(pointName);
  }
}

function makeMidpoints() {
  let maxCoords = getMaxCoords("'"),
      maxX = maxCoords[0],
      maxY = maxCoords[1];

  ggbApplet.evalCommand("X_MID = (" + maxX/2 + ", " + maxY + ")");
  ggbApplet.evalCommand("X_ZERO = (" + 0 + ", " + maxY + ")");
  ggbApplet.evalCommand("Y_MID = (" + maxX + ", " + maxY/2 + ")");
  ggbApplet.evalCommand("Y_ZERO = (" + maxX + ", " + 0 + ")");
  ggbApplet.evalCommand("XY_MAX = (" + maxX + ", " + maxY + ")");

  ggbApplet.setColor("X_MID", 255, 0, 0);
  ggbApplet.setColor("Y_MID", 255, 0, 0);
  ggbApplet.setColor("XY_MAX", 255, 0, 0);
  ggbApplet.setVisible("X_ZERO", false);
  ggbApplet.setVisible("Y_ZERO", false);

  ggbApplet.evalCommand("TOP_SEG = Segment(X_ZERO, XY_MAX)");
  ggbApplet.evalCommand("RIGHT_SEG = Segment(Y_ZERO, XY_MAX)");
  ggbApplet.setLineStyle("TOP_SEG", 1);
  ggbApplet.setLineStyle("RIGHT_SEG", 1);

  ggbApplet.registerObjectUpdateListener("Y_MID", "dilateXListener");
  ggbApplet.registerObjectUpdateListener("X_MID", "dilateYListener");
}

function getDilationRules() {
  let xRule = ggbApplet2.getValueString("D2"),
      yRule = ggbApplet2.getValueString("E2");

  return [parseFloat(xRule.slice(0, xRule.indexOf("x"))), parseFloat(yRule.slice(0, yRule.indexOf("y")))];
}

function pointListener(objName) {
  if (!isLocked("pointListener")) {
    lock("sheetListener");
    lock("dilationListener");
    lock("ruleListener");
    console.log("Point listener: " + objName);
    let newX = ggbApplet.getXcoord(objName),
        newY = ggbApplet.getYcoord(objName),
        row = gridObjToSpreadSheetRow(objName);

    let newCoords = getPointCoords(objName),
        spreadsheetRow = gridObjToSpreadSheetRow(objName),
        oldCoords = getRowCoords(spreadsheetRow);

    ggbApplet2.setValue("A" + row, newX);
    ggbApplet2.setValue("B" + row, newY);

    let dilationRules = getDilationRules();
    ggbApplet2.setValue("D" + row, newX * dilationRules[0]);
    ggbApplet2.setValue("E" + row, newY * dilationRules[1]);

    makeMidpoints();

    unlock("ruleListener");
    unlock("sheetListener");
    unlock("dilationListener");
  }
}

// TODO: merge these into a single dilate listener
function dilateXListener(objName) {
  if (!isLocked("dilationListener")) {
    console.log("Dilate X listener: " + objName);
    lock("pointListener");
    lock("dilationListener");
    let newX = ggbApplet.getXcoord(objName),
        baseX = getMaxCoords()[0],
        dilation = newX / baseX,
        roundedDilation = Math.round(newX / baseX * 100) / 100;

    if (Math.abs(dilation - getDilationRules()[0]) > .01) {
      ggbApplet2.setTextValue("D2", roundedDilation + "x");
    }

    unlock("pointListener");
    unlock("dilationListener");
  }
}

function dilateYListener(objName) {
  if (!isLocked("dilationListener")) {
    console.log("Dilate Y listener: " + objName);
    lock("pointListener");
    lock("dilationListener");
    let newY = ggbApplet.getYcoord(objName),
        baseY = getMaxCoords()[1],
        dilation = newY / baseY,
        roundedDilation = Math.round(newY / baseY * 100) / 100;

    if (Math.abs(dilation - getDilationRules()[1]) > .01) {
      ggbApplet2.setTextValue("E2", roundedDilation + "y");
    }

    unlock("pointListener");
    unlock("dilationListener");
  }
}

function sheetListener(objName) {
  if (!isLocked("sheetListener")) {
    lock("dilationListener");
    lock("pointListener");
    lock("ruleListener");
    console.log("Sheet listener: " + objName);
    let rowNum = parseInt(objName.slice(1)),
        gridObj = spreadSheetRowToGridObj(rowNum),
        oldCoords = getPointCoords(gridObj),
        newCoords = getRowCoords(rowNum);

    ggbApplet.setCoords(gridObj, newCoords[0], newCoords[1]);

    let dilationRules = getDilationRules();
    ggbApplet2.setValue("D" + rowNum, newCoords[0] * dilationRules[0]);
    ggbApplet2.setValue("E" + rowNum, newCoords[1] * dilationRules[1]);

    unlock("ruleListener");
    unlock("dilationListener");
    unlock("pointListener");
  }
}

function ruleListener(objName) {
  if (!isLocked("ruleListener")) {
    lock("pointListener");
    lock("sheetListener");

    console.log("Rule listener: " + objName);
    let dilations = getDilationRules();
    pointNames.forEach(pointName => {
      let basePointCoords = getPointCoords(pointName),
          newPointCoords = [basePointCoords[0] * dilations[0], basePointCoords[1] * dilations[1]],
          row = gridObjToSpreadSheetRow(pointName);

      ggbApplet2.setValue("D" + row, newPointCoords[0]);
      ggbApplet2.setValue("E" + row, newPointCoords[1]);
    });

    unlock("sheetListener")
    unlock("pointListener");
  }
}

function sheetTransformationListener(objName) {
  if (!isLocked("sheetTransformationListener")) {
    lock("pointListener");
    lock("dilationListener");
    lock("ruleListener");
    console.log("Sheet transform listener: " + objName);
    let rowNum = parseInt(objName.slice(1)),
        gridObj = spreadSheetRowToGridObj(rowNum) + "'",
        oldCoords = getPointCoords(gridObj),
        newCoords = getRowCoords(rowNum, "D", "E");

    ggbApplet.setCoords(gridObj, newCoords[0], newCoords[1]);

    makeMidpoints();

    unlock("ruleListener");
    unlock("pointListener");
    unlock("dilationListener");
  }
}

var parameters = {
"id": "ggbApplet",
"width":1000,
"height":750,
"showMenuBar":true,
"showAlgebraInput":false,
"showToolBar":true,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id":"c23xKskj"};


var parameters2 = {
"id": "ggbApplet2",
"width":1000,
"height":750,
"showMenuBar":true,
"showAlgebraInput":false,
"showToolBar":true,
"showToolBarHelp":false,
"showResetIcon":false,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":true,
"errorDialogsActive":false,
"useBrowserForJS":true,
"preventFocus":false,
"language":"en",
"material_id":"uKg8Y9WS",
};

// is3D=is 3D applet using 3D view, AV=Algebra View, SV=Spreadsheet View, CV=CAS View, EV2=Graphics View 2, CP=Construction Protocol, PC=Probability Calculator, DA=Data Analysis, FI=Function Inspector, PV=Python, macro=Macro View
var views = {'is3D': 0,'AV': 1,'SV': 1,'CV': 0,'EV2': 0,'CP': 0,'PC': 0,'DA': 0,'FI': 0,'PV': 0,'macro': 0};

var applet = new GGBApplet(parameters, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');
var applet2 = new GGBApplet(parameters2, '5.0', views);
              
    //  when used with Math Apps Bundle, uncomment this:
    //  applet2.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');

window.onload = function() {
  applet.inject('ggbApplet');
  applet2.inject('ggbApplet2');
};

</script> 
     </div>
</table> 
</body> 
</html> 